<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1427724114239">{:repl-history {:ide [], :local [&quot;(ns homework05\n  \&quot;The first homework assignment using Clojure for NAU‘s COMP 3320.\&quot;\n  (:require [clojure.test :refer :all]))&quot; &quot;(meditations\n  \&quot;Clojure has a number of primitives.  These are low-level types that\n  represent simple values.  Let‘s start with simple integer literals.\&quot;\n  (integer? __))&quot; &quot;(ns homework05\n  \&quot;The first homework assignment using Clojure for NAU‘s COMP 3320.\&quot;\n  (:require [clojure.test :refer :all]\n            [homework05.util :refer :all]))&quot; &quot;(require :reload-all 'homework05)&quot; &quot;(deftest vectors\n  ; In addition to lists, Clojure also supports vectors.  Like lists, vectors\n  ; are sequential collections of values.  However, they behave much more like\n  ; dynamic arrays, with relatively efficient access to elements by index.\n  (testing \&quot;constructing vectors\&quot;\n    ; In Clojure source code, vectors are constructed by square braces with zero\n    ; or more forms inside.\n    (is (vector? [1 2 3]))\n    (is (vector? __))\n    (is (vector? __))\n    (is (vector? __))\n    (is (vector? __))\n    (is (vector? __))\n\n    ; Similarly to lists, you can build vectors using the ‘vector’ function.\n    (is (= [1 2 3] (vector 1 2 3)))\n    (is (= __ (vector \\a \\b \\c)))\n    (is (= ['a 'b 'c] (vector __ __ __))))\n\n  (testing \&quot;generic operations\&quot;\n    ; Vectors support the ‘count’, ‘conj’, and ‘seq’ functions, like all\n    ; collections.\n    (is (= 3 (count [\&quot;a\&quot; \&quot;b\&quot; \&quot;c\&quot;])))\n    (is (= __ (count [\\c \\l \\o \\j \\u \\r \\e])))\n    (is (= 0 (count __)))\n\n    ; In the case of vectors, ‘conj’ appends to the end of the vector.\n    (is (= [1 2 3] (conj [1 2] 3)))\n    (is (= [1 2] (conj [1] __)))\n    (is (= __ (conj [] 2)))\n    (is (= __ (conj ['a \\b :c] 4)))\n    (is (= __ (conj [1 2] 3 4 5)))\n\n    ; Finally, using ‘seq’ on a vector produces something that is no longer a\n    ; vector.  Nor is the result a list, but it is a sequence nonetheless.\n    ; Type some vectors into the blanks.\n    (is (not (vector? (seq __))))\n    (is (not (list? (seq __))))\n    (is (seq? (seq __)))\n    ; What happens if you try to ‘seq’ an empty vector?\n    (is (nil? (seq __))))\n\n  (testing \&quot;equivalence of vectors with lists and sequences\&quot;\n    ; Two sequential lists are considered equivalent if they have elements in\n    ; the same order.  This means that Clojure‘s equivalence checks on\n    ; collections do not depend on the type of the collection.\n    (is (= '(1 2 3) [1 2 3] (seq [1 2 3])))\n\n    ; However, order of the data is important.\n    (is (not= [1 2 3] [3 1 2]))\n\n    ; Create lists equal to these vectors and vice-versa\n    (is (= __ [:a :b :c]))\n    (is (= __ []))\n    (is (= '(\\a \&quot;a\&quot; :a) __))\n    (is (= '(5 4 3 2 1) __))) \n\n  (testing \&quot;vectors as indexed collections\&quot;\n    ; Due to the nature of vectors, they support some extra vector-specific\n    ; operations.  The first of these is ‘nth’, which returns the value at the\n    ; given index.\n    (is (= 3 (nth [0 1 2 3 4 5] 3)))\n    (is (= __ (nth [:a :b :c :d :e] 2)))\n    (is (= \\3 (nth [\\1 \\2 \\3 \\4] __)))\n\n    ; Additionally, it's possible to supply a ‘not-found’ value.   What happens\n    ; when trying to access an out-of-bounds value with ‘nth’?\n    (is (= :not-found (nth [] 3 :not-found)))\n    (is (= __ (nth [1 2 3] 3 :not-found)))\n    (is (= __ (nth [1 2 3 4] 3 :not-found)))\n    (is (= __ (nth [:a :b :c] -1 nil)))\n    (is (= 5 (nth [1 2 3] 42 __))))\n\n  (testing \&quot;vectors as associative collections\&quot;\n    ; In Clojure, some collections are said to be associative, meaning that\n    ; given a key, the collection can look up an associated value.  Vectors are\n    ; associative by index.\n    ;\n    ; The primary way to get a value within an associative collection is ‘get’.\n    ; You can pass a collection and a key to ‘get’ to retrieve the value for\n    ; that key.  You can also pass a ‘not-found’ value.\n    (is (= 3 (get [0 1 2 3] 3)))\n    (is (= :not-found (get [0 1 2 3] 6 :not-found)))\n    (is (= __ (get [:a :b :c] 2)))\n    (is (= :foo (get [:a :b :c] __ __)))\n    ; note how ‘get’ differs from ‘nth’ when the index is out of bounds\n    (is (= __ (get [:a :b :c] 3))))\n\n  (testing \&quot;vectors as functions\&quot;\n    ; One last bit before we move on from vectors: they also act as functions.\n    ; You can place a vector in function call position and pass it an index to\n    ; get the value at that index.\n    (is (= 2 ([0 1 2 3 4 5] 2)))\n    (is (= __ ([\\a \\b \\b \\c \\d] 2)))\n    (is (= :c ([:a :b :b :c :d] __)))))&quot;], :remote []}}</component>
</project>